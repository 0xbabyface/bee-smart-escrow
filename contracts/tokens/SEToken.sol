// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
ğŸŒ€é¡¹ç›®åç§°ï¼šSE
â“‚ï¸å‘è¡Œæœºåˆ¶ï¼šæ€»é‡4äº¿æš
50% å…¨ç½‘ğŒğ¢ğ§ğ­
25% æ°¸ä¹…ğ‹ğæ± 
25%ä¸Šçº¿é”€æ¯
â‡ï¸å‘è¡Œä»·æ ¼ï¼šğŸ¬.ğŸ¬ğŸ¬ğŸ­ğ”/æš
âœ³ï¸é“¸é€ ä»·æ ¼ï¼š4ğŸ¬$/ä»½=4ğŸ¬ğŸ¬ğŸ¬ğŸ¬æš

ğŸ’¹äº¤æ˜“æœºåˆ¶ï¼šä¹°å–å„5%
1%ğğ…ğ“åˆ†çº¢ã€ˆç¤¾åŒºé•¿åˆ†çº¢ã€‰
1%ç”Ÿæ€åŸºé‡‘ã€ˆç”Ÿæ€æ¿€åŠ±æ± ã€‰
3% LPåˆ†çº¢ã€ˆå¾—ğğğæ°¸ä¹…åˆ†çº¢ã€‰(ä¹°å–5%ç¨ç‚¹çš„å¸å…¨éƒ¨é”€æ¯ï¼Œä½†æ˜¯BNBæµå…¥åˆ°ç›¸åº”çš„åˆ†çº¢æ± )

Lpæœºåˆ¶ï¼š
æ·»åŠ Lpç¨ç‚¹1%ç»™NFTæŒæœ‰è€…åˆ†çº¢ï¼Œæ’¤Lpç¨ç‚¹20%ï¼Œå…¶ä¸­10%çš„ä»£å¸é”€æ¯ï¼Œå¦å¤–10%æµå…¥LPåˆ†çº¢æ± ï¼Œ

å½“SEæµé€šé‡åªæœ‰200ä¸‡æšæ—¶ï¼Œå–æ¶ˆæ‰€æœ‰ç¨ç‚¹åœæ­¢é”€æ¯

ğŸ”¯å¤‡æ³¨ï¼šç¤¾åŒºé•¿åˆ†çº¢è¿˜æ˜¯æŒ‰32å¼ NFTå¡ç‰Œé“¸é€ 

è½¬è´¦ï¼Œå–ï¼Œåœ°å€éƒ½ç•™ä¸‹0.2%(åƒåˆ†ä¹‹2)ï¼Œä¿æŒæŒå¸åœ°å€

DAPPé¢„ç•™ä¸€ä¸ªMinté¡µé¢ï¼Œä»¥40æ²¹ä¸ºåŸºæ•°Mintï¼Œä¸è®¾ä¸Šé™åªéœ€è¦40çš„å€æ•°å³å¯

è®¾å®šå¼€ç›˜æ—¶é—´ï¼Œå¼€ç›˜æ»‘ç‚¹ï¼š1åˆ†é’Ÿï¼Œä¹°å–30%ï¼Œ2ï½30åˆ†é’Ÿï¼Œä¹°5%ï¼Œå–30%ï¼Œ30ï½59åˆ†é’Ÿï¼Œä¹°5%å–10ï¼›1å°æ—¶ååæ­£å¸¸ç¨ç‚¹ã€‚é«˜ç¨æ”¶å…¥æµå…¥ç”Ÿæ€æ¿€åŠ±æ± 

// è´¦å·ä¿¡æ¯

SE$ï½Minté’±åŒ…åœ°å€ï¼ˆMintçš„æ²¹è¿›è¿™ä¸ªåœ°å€ï¼‰
0x6Cd24A63947548fe6290Fe777B6A3419449Ea28F

SE$~ç”Ÿæ€åŸºé‡‘æ± åˆ†çº¢åœ°å€ï¼ˆä¹°å–ç¨ç‚¹1%å’Œä¸Šçº¿é«˜ç¨æ”¶è¿›å…¥è¿™ä¸ªåœ°å€ï¼Œå•çº¯çš„å­˜æ”¾ä¸åšåˆçº¦ï¼‰
0x1a08C6f79440656536c027Cb9ab0cB671Ce6c7Ad

SE$ï½NFTåˆ†çº¢åˆçº¦ï¼ˆä¹°å–ç¨ç‚¹çš„1%å’Œæ·»åŠ Lpç¨ç‚¹1%è¿›å…¥è¿™ä¸ªåœ°å€ï¼Œç„¶åå†å®æ—¶åˆ†é…ç»™æŒæœ‰NFTçš„åœ°å€ï¼‰
0x4c6F3f6606ae063DB221CD60eCB8C9F6d085C731

SE$ï½LPæµåŠ¨æ€§åˆ†çº¢åˆçº¦ï¼ˆä¹°å–ç¨æ”¶çš„3%å’Œæ’¤Lpçš„10%è¿›å»è¿™ä¸ªåœ°å€ï¼Œç„¶åå®æ—¶æŒ‰æƒé‡åˆ†é…ç»™æ·»åŠ Lpçš„åœ°å€ï¼‰
0x8b7D471e1496b04164baF6b4dc7d41a5de46Ff16

SE$ï½32å¼ NFTæ¥æ”¶åœ°å€ï¼ˆèŒƒå¸ˆå‚…é“¸é€ å‡ºæ¥çš„NFTæ”¾è¿™ä¸ªåœ°å€å³å¯ï¼‰0x1eF6E29cC8A97b96b02430465980996e05E51726
 */


// åˆ¤æ–­æ·»åŠ è¿˜æ˜¯æ’¤é™¤æµåŠ¨æ€§:
// addLiquidity: msg.sender == router,  from = user, to = pair
// removeLiquidity:  msg.sender == router,  from = pair, to = user

// åˆ¤æ–­äº¤æ˜“:
//  sell: from = pair, to = user
//  buy:  from = user, to = pair
contract SEToken is ERC20Capped {

    uint256 constant MaxSupply = 400_000_000 *  10**18;
    address constant DeadAddress = 0x000000000000000000000000000000000000dEaD;
    uint256 constant TotalMintable = MaxSupply / 2;  // 50% for mint

    uint256 public mintAmount;
    address public usdtAddress;

    constructor(address _usdt) ERC20Capped(MaxSupply) ERC20("SE Token", "SE") {
        usdtAddress = _usdt;

        _mint(DeadAddress, MaxSupply / 4);  // burn 25%
    }

    function buy(uint256 times) external {

    }

}
